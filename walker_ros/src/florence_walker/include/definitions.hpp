// File contains some general definitions used by all the other classes
// Since most classes use Eigen, the library is included here

#ifndef DEFINITIONS_
#define DEFINITIONS_ // header guard prevents redefinitions

#include <Eigen/Core>
#include <Eigen/Geometry>
#include <unsupported/Eigen/EulerAngles>

// EXCLUSIVELY THE ROBOT INTERFACE
///////////////////////////////////////////////////////////////////////////////////////////
#define OUT_ACTIVE 1      									//should the output be active?
///////////////////////////////////////////////////////////////////////////////////////////
#define RI_DEBUG 0        									//display some internal variables
#define USE_ALL_MEAS 0										//should all measurements be used (is not recommended)
///////////////////////////////////////////////////////////////////////////////////////////
// CTRL VARS
#define FULL_CTRL_DEBUG 0 									// debugging of the FlorenceFullControl class




///////////////////////////////////////////////////////////////////////////////////////////
// Do not change any of the following definitions
#define NDOF_FB 6											// number of degrees of freedom of the floating base
#define NDOF 12 											// number of degrees of freedom (model joints)
#define NMOT 16 											// number of motors
#define NFS 2												// number of force sensors
#define NMOD (NFS+NMOT)										// total number of modules
#define NLC 4												// number of load cells per leg

#define LBF2NEWT 4.448f										// lbf to newton transformation constant
#define VOLT2NEWT (100.0f*LBF2NEWT/4.0f) 					// transforms from volt over lbs to newton
#define GRAV 9.81f

// QP problem
#define NVRBL (NDOF_FB + NDOF)								// total number of optimization variables
#define NCSTR (NDOF_FB + NDOF_FB + NDOF_FB/2)				// total number of optimization constraints
///////////////////////////////////////////////////////////////////////////////////////////

// Trajectory generator
#include "preview_settings.h"								// generated by a matlab script


// Enumarations
typedef enum {IDLE, RUNNING, STOPPED, ERROR} ctrl_states;	// each of the controllers should forward one of these states to its respective VisNode

// Type definitions
typedef Eigen::Matrix<double,NDOF,1> stateVector;
typedef Eigen::Matrix<double,NMOT,1> ioVector;
typedef Eigen::Matrix<double,NDOF,NMOT> io2stateMat;
typedef Eigen::Matrix<double,NMOT,NDOF> state2ioMat;
typedef Eigen::Matrix<double,NDOF_FB,NVRBL> WorldJacobian;

typedef Eigen::Matrix<double,6,1> polyCoefVec;
typedef Eigen::Matrix<double,NLC,1> Vector4d;

// Structures
typedef struct{
	double wshiftL;									// how much weight should the left foot carrying
	double wshiftR;									// how much weight should the right foot carrying
	int phase;										// 0 for double support phase, 1 for single support phase
} phase_data;

typedef struct{
	phase_data pd;									// phase data information
	Eigen::Vector3d	pL, pR;							// left foot and right foot postions in world frame
	Eigen::Vector3d pLp, pRp;						// left foot and right foot velocities in world frame
	Eigen::Vector3d zmp;							// zmp position in world frame
} pattern_gen_out;									// output of the pattern generator

#endif